  
module Vector2Ds # обернём оределение типа и соответсвующих функций в модуль Vector2Ds. 

export Vector2D, xdot, sin, cos
using LinearAlgebra # - чтобы стали доступными фунции dot (скалярное произведение), norm (длина вектора)

Vector2D{T<:Real} = Tuple{T,T} # Vector2D{T} - это просто псевдоним Tuple{T,T}.

Base. cos(a::Vector2D, b::Vector2D) = dot(a,b)/norm(a)/norm(b)
xdot(a::Vector2D, b::Vector2D) = a[1]*b[2]-a[2]*b[1]  # xdot(a,b)=|a||b|sin(a,b) - косое произведение
       
Base. sin(a::Vector2D, b::Vector2D) = xdot(a,b)/norm(a)/norm(b)
end

using Plots

# Задача 1. Написать функцию, возвращающу одномерный массив заданной длины, содержаий случайные точки плоскости типа Vector2D.
randpoints(random::Function, num::Integer) = [(random(),random()) for _ in 1:num]

# Задача 2. Написать функцию, которая получает на вход массив точек плоскости типа Point2D и отображает их на графике.
points = randpoints(rand, 20)
scatter(points; legend = false) # scatter() - график разброса точек

# Задача 3. Написать функцию, получающую вектор кортежей, содержащих пары точек типа Vector2D, и возвращающую графический объект (типа Plots.Plot), содержащий изображение соответствующих отрезков, расположенных на плоскости.

function plotsegments(segments::Vector{Tuple{Point2D,Point2D}}; kwargs...)
    pyplot = plot(;kwargs...)
    for s in segments
        plot!(collect(s); kwargs...)
    end
    return p
end

# задача 4. Написать функцию, которая бы получала на вход аргумент segments, представляющий собой массив типа Vector{Tuple{Point2D,Point2D}}, 
# или - генератор последовательности элементов типа Tuple{Point2D,Point2D} (представляющих некоторые отрезки),
# и возвращающую графический объект типа Plots.Plot, содержащий графики этих отрезков. 
# Причем все точки пересечения этих отрезков толжна быть помечены красным крестообразным маркером.

using .Vector2Ds
Point=Vector2D
Segment{T<:Real} = Tuple{Point{T},Point{T}}

function intersect((A₁,B₁)::Segment, (A₂,B₂)::Segment)    
    A = [B₁[2]-A₁[2]  A₁[1]-B₁[1]
         B₂[2]-A₂[2]  A₂[1]-B₂[1]]

    b = [A₁[2]*(A₁[1]-B₁[1])+A₁[1]*(B₁[2]-A₁[2])
         A₂[2]*(A₂[1]-B₂[1])+A₂[1]*(B₂[2]-A₂[2])]

    x,y = A\b

    if isinner((x, y), (A₁,B₁))==false || isinner((x, y), (A₂,B₂))==false
        return nothing
    end

    return (x,y)
end

isinner(P::Point, (A,B)::Segment) = 
    (A[1] <= P[1] <= B[1] || A[1] >= P[1] >= B[1]) &&
    (A[2] <= P[2] <= B[2] || A[2] >= P[2] >= B[2])


#=Задача 5. Написать функцию, получающую на вход последовательность точек плоскости (их массив или генератор) и 
# ещё пару точек плоскости, определяющих некоторую прямую. Функция должна вернуть графический объект типа Plots.Plot, 
содержащий график этих точек (в виде круглых маркеров) и график заданной прямой, причем все точки должны быть раскрашены в два цвета 
(синий и красный) таким образом, чтобы все точки лежащие по одну сторону от прямой были бы раскрашены в какой-то один цвет, 
и точки лежащие по разную сторону от прямой были бы разного цвета.=#

function podsvetca(a,x1,y1, x2, y2)
    k = (y2 - y1)/(x2 - x1) # находим коэффициент прямой, проходящей черещ точки M(x1;y1), M(x2;y2)
    b = y1 - k*x1   # находим свободный член прямой, проходящей черещ точки M(x1;y1), M(x2;y2)
    for i in 1:length(a)
            if a[i+1] < k*a[i] + b # Если точка ноходиться ниже прямой
                    plot!(a[i], a[i+1,] color = "red") # то красим в красный
            end
            if a[i+1] > k*a[i] + b # Если точка ноходиться выше прямой
                    plot!(a[i], a[i+1,] color = "blue") # то красим в синий
            end
            i += 2
            if i<= length(a)-2
                Line(xdata=(a[i], a[i+1,]), ydata=(a[i+3], a[i+2,])) # строим прямую y = k*x + b, , проходящую черещ точки M(x1;y1), M(x2;y2)
    end
end

#Задача 6. Написать функцию, получающую на вход последовательность точек плоскости (их массив или генератор) 
#и ещё одну последовательность точек, определяющую координаты вершин некоторого 2 в порядке его обхода 
#в одном из двух возможных направлений (например, для большей определенности, - в положительном). 
#Многоугольник не обязательно выпуклый, но без самопересечений сторон. Функция должна вернуть графический объект типа Plots.Plot, 
#содержащий график этих точек (в виде круглых маркеров) и график заданного многугольника, причем все точки должны быть раскрашены так, 
#чтобы все точки лежащие внутри многоугоугольника были бы красного цвета, а все точки лежащие снаружи - в синего.

function polygon_colour(B::Vector,C::Vector) #  B - вектор абсцисс точек Многоуголника в порядке обхода, C - вектор абсцисс точек Многоуголника в порядке обхода
    n = length(B)                               
    for i in 0 : n # по очереди строим стороны многоугольника
        for j in 1:length(B)
            k = (С[mod(i+1,n)] - С[i])/(B[mod(i+1,n)] - B[i]) # находим коэффициент прямой
            b = C[i] - k*B[i]  # находим свободный член прямой
            if C[j] < k*B[j] + b # Если точка ноходиться внутри многоугольника
                plot!(B[j], C[j,] color = "red") # то красим в красный
            end
            if C[j] > k*B[j] + b # Если точка ноходиться вне многоугольника
                    plot!(B[j], C[j,] color = "blue") # то красим в синий
            end
            j += 2
            if j<= length(B)-2
                Line(xdata=(B[j], B[mod(j+1,n),]), ydata=(C[mod(j+1,n)], C[j,])) #строим прямую y = k*x + b
            end   
    end
end

#Задача 7. Дана последовательность точек плоскости, определяющая вершины некоторго многоугольника (в порядке их обхода в одном из двух возможных направлений). 
# Требуется написать функцию, получающую на вход такую последовательность и возвращающую значение true, если многоугольник выпуклый, или значение false - в противном случае.

function polygon_convex(a::Array,n::Int)

    flag1 = false
    flag2 = false

    for i in 1:n 
            x1 = a[i][1]
            y1 = a[i][2]
            x2 = a[(i+1)%n][1]
            y2 = a[(i+1)%n][2]
            x3 = a[(i+2)%n][1]
            y3 = a[(i+2)%n][2]
            d = (x2-x1)*(y3-y2)-(y2-y1)*(x3-x2)
            if d>0
                flag1 = true
            else
                flag2 = true
            end
    end

    if flag1 && flag2
            return false
    else
            return true
    end
end

# Задача 8. Написать функцию, получающую на вход последовательнсть точек плоскости и следующий набор параметров, определяющих эллипс:
# a, b - величины большой и малой полуосей эллипса, соответственно, (x_0, y_0) - координаты его центра, 
# phi - угол поворота большой полуоси эллипса относительно положительного направления оси OX. 
# Функция должна вернуть графический объект типа Plots.Plot, содержащий график этих точек (в виде круглых маркеров) и график заданного эллипса, причем все точки должны быть раскрашены так, чтобы все точки лежащие внутри эллипса были бы красного цвета, а все точки лежащие снаружи - в синего.

function ellipse(B::Vector,C::Vector,x0::Float64,y0::Float64,a::Float64,b::Float64) # B - вектор абсцисс точек Многоуголника в порядке обхода, C - вектор абсцисс точек Многоуголника в порядке обхода
    n = length(B)
    x1 = b + x0
    x2 = -b + x0
    y1 = a + y0
    y2 = -a + y0

    for i in x2:x1
        for j in y2:y1 
            
            if abs(C[j]) < sqrt((pow(b,2)*(pow(a,2)-pow(B[i],2)))/pow(a,2)) # Если точка ноходиться внутри Эллипса
                plot!(B[i], C[j,] color = "red") # то красим в красный
            end
            if if abs(C[j]) > sqrt((pow(b,2)*(pow(a,2)-pow(B[i],2)))/pow(a,2))b # Если точка ноходиться вне Эллипса
                    plot!(B[i], C[j,] color = "blue") # то красим в синий
            end  
        end
    end
    for i in x0:x1
        for j in y0:y1
            Line(xdata=(-sqrt((pow(a,2)*(pow(b,2)-pow(B[i],2))))/pow(b,2), -sqrt((pow(b,2)*(pow(a,2)-pow(B[mod(i+1,n),],2))))/pow(a,2), ydata=(sqrt((pow(b,2)*(pow(a,2)-pow(C[mod(i+1,n)],2))))/pow(a,2),sqrt((pow(b,2)*(pow(a,2)-C[i,]))pow(b,2))))    
            Line(xdata=(sqrt((pow(a,2)*(pow(b,2)-pow(B[i],2))))/pow(b,2), sqrt((pow(b,2)*(pow(a,2)-pow(B[mod(i+1,n),],2))))/pow(a,2), ydata=(-sqrt((pow(b,2)*(pow(a,2)-pow(C[mod(i+1,n)],2))))/pow(a,2),-sqrt((pow(b,2)*(pow(a,2)-C[i,]))/pow(b,2))))
            Line(xdata=(sqrt((pow(a,2)*(pow(b,2)-pow(B[i],2))))/pow(b,2), sqrt((pow(b,2)*(pow(a,2)-pow(B[mod(i+1,n),],2))))/pow(a,2), ydata=(sqrt((pow(b,2)*(pow(a,2)-pow(C[mod(i+1,n)],2))))/pow(a,2),sqrt((pow(b,2)*(pow(a,2)-C[i,]))pow(b,2))))
            Line(xdata=(-sqrt((pow(a,2)*(pow(b,2)-pow(B[i],2))))/pow(b,2), -sqrt((pow(b,2)*(pow(a,2)-pow(B[mod(i+1,n),],2))))/pow(a,2), ydata=(-sqrt((pow(b,2)*(pow(a,2)-pow(C[mod(i+1,n)],2))))/pow(a,2),-sqrt((pow(b,2)*(pow(a,2)-C[i,]))pow(b,2))))
            # Строим Эллипс           
end